import enum
import threading
import logging

from PySide6 import QtCore
from PySide6.QtCore import QDeadlineTimer


log = logging.getLogger(__name__)


class TaskFailureException(Exception):
    """
    Signals that the task failed. If provided, the first argument will be displayed to the user as an error dialog.
    """
    pass


class TaskCancelledException(Exception):
    """
    Signals that the task was cancelled.
    """
    pass


class TaskContinuingException(Exception):
    """
    Signals that the task's execution has finished, but that the task status should not be updated to ``SUCCESS``.
    Primarily used by ``TaskSequence``, but can be used in other cases where task success status will be set manually.
    """
    pass


class Status(enum.IntEnum):
    NOT_STARTED = 0
    WORKING = 1
    SUCCESS = 2
    FAILURE = 3
    CANCELLED = 4


class Task(QtCore.QThread):
    signal_status = QtCore.Signal(int)
    signal_progress = QtCore.Signal(float)
    signal_error = QtCore.Signal(str)

    signal_started = QtCore.Signal()
    signal_success = QtCore.Signal()
    signal_failure = QtCore.Signal()
    signal_cancelled = QtCore.Signal()

    def __init__(self, parent: QtCore.QObject | None, name: str, *, hidden: bool = False):
        """
        A single step in a process. Execution takes place in a separate thread, and details of execution are
        reported using signals. Unlike ``QThread``, implementation should be defined by overriding ``run_impl()``
        instead of ``run()``.

        The following primary signals are defined:
          * ``signal_status``: Emitted when the task status changes. The new status is provided as an argument.
          * ``signal_progress``: Emitted when the task progress changes. The progress is provided as an argument. Values
            0.0 through 1.0 are emitted for percentage values, and a negative value is emitted for indeterminate values.
          * ``signal_error``: Emitted when an error message is generated by a task failure. The error message is
            provided as an argument. Note that this signal will not be emitted if a task failure occurs without an error
            message.

        Some convenience signals for specific statuses are also defined:
         * ``signal_started``: Emitted when the task status becomes ``WORKING``
         * ``signal_success``: Emitted when the task status becomes ``SUCCESS``
         * ``signal_failure``: Emitted when the task status becomes ``FAILURE``
         * ``signal_cancelled``: Emitted when task status becomes ``CANCELLED``

        :param parent: Parent ``QObject``, see ``QThread``.
        :param name: Name of the task, as shown to the user.
        :param hidden: Whether the task should be shown to the user.
        """
        super().__init__(parent)
        self.name = name
        self.hidden = hidden

        self._status_lock = threading.Lock()
        self._status: Status = Status.NOT_STARTED

        self._cancel_lock = threading.Lock()
        self._cancelled = False

    def set_status(self, status: Status):
        """
        Sets the status of the task. This method is thread-safe.

        Generally, this method should not be used unless managing task state manually. Instead, implementations should
        manage status as documented by ``run_impl()``.

        :param status: Status to set.
        """
        log.debug(f'Task "{self.name}": Status = {status.name}')

        with self._status_lock:
            self._status = status

        if status == Status.WORKING:
            self.signal_started.emit()
        elif status == Status.SUCCESS:
            self.signal_success.emit()
        elif status == Status.FAILURE:
            self.signal_failure.emit()
        elif status == Status.CANCELLED:
            self.signal_cancelled.emit()

        self.signal_status.emit(status)

    def get_status(self) -> Status:
        """
        Gets the status of the task. This method is thread-safe.
        :return: Status of the task.
        """
        with self._status_lock:
            return self._status

    def cancel(self):
        """
        Sets the "cancelled" flag of the task. This method is thread-safe.

        The "cancelled" flag, on its own, does not affect the execution of the task. However, it signals to the task
        implementation that its execution should be halted. The implementation should frequently check for this flag
        using ``is_cancelled()``, and raise ``TaskCancelledException`` if it was set.
        """
        log.debug(f'Task "{self.name}": Cancelling')
        with self._cancel_lock:
            self._cancelled = True

    def is_cancelled(self) -> bool:
        """
        Checks the "cancelled" flag of the task. This method is thread-safe.
        :return: ``True`` if the task was cancelled, ``False`` otherwise.
        """
        with self._cancel_lock:
            return self._cancelled

    def report_progress(self, progress: float | None):
        """
        Reports the progress of the task.
        :param progress: Progress of the task, as a percentage from 0.0 to 1.0. ``None`` represents an indeterminate
            completion state.
        """
        if progress is None:
            self.signal_progress.emit(-1.0)
        else:
            self.signal_progress.emit(max(0.0, min(1.0, progress)))

    def run(self):
        """
        Executes the task. Generally, task implementations should implement ``run_impl()`` instead, unless they wish to
        manage task status manually.
        """
        self.set_status(Status.WORKING)
        try:
            if self.is_cancelled():
                raise TaskCancelledException()
            self.run_impl()
        except TaskContinuingException:
            pass
        except TaskCancelledException:
            self.set_status(Status.CANCELLED)
        except TaskFailureException as e:
            self.set_status(Status.FAILURE)
            if str(e):
                self.signal_error.emit(str(e))
        except Exception as e:
            log.error(f'Exception occurred in task thread "{self.name}":', exc_info=e)
            self.set_status(Status.FAILURE)
            self.signal_error.emit("An unknown error occurred. See the log file for more information.")
        else:
            self.set_status(Status.SUCCESS)

    def run_impl(self):
        """
        The implementation of the task. This method will be run in a different thread than the one in which ``start()``
        was called, and generally acts as the parallel to ``QThread.run()``. Subclasses implementing this method should
        not call the implementation provided in this class, which raises ``NotImplementedError``.

        In general, implementations of this method should let execution complete when the task is successful, raise
        ``TaskFailureException`` when an error occurs, and raise ``TaskCancelledException`` when cancellation is
        detected by periodically checking ``is_cancelled()``.
        """
        raise NotImplementedError()


class TaskSequence(Task):
    def __init__(self, parent: QtCore.QObject | None, name: str):
        """
        A subclass of ``Task`` that allows task sequencing. When the task is started, each subtask will be started in
        sequence, only starting when the previous subtask is successful. The task status is related to its subtasks in
        intuitive ways:
         * If the final subtask is successful, the task is successful.
         * If one of the subtasks fails, the task fails.
         * If the task is cancelled, all subtasks are cancelled.
        :param parent: Parent ``QObject``, see ``QThread``.
        :param name: Name of the task, as shown to the user.
        """
        super().__init__(parent, name)
        self.subtasks: list[Task] = []

    def run_impl(self):
        """
        Connects each subtask together for sequencing, and to this task for status control, then starts the first task.
        """
        for task, next_task in zip(self.subtasks, self.subtasks[1:]):
            task.signal_success.connect(next_task.start)

        for task in self.subtasks:
            task.signal_status.connect(self._on_subtask_status_updated)
            task.signal_error.connect(self.signal_error)

        if self.subtasks:
            self.subtasks[0].start()
            raise TaskContinuingException()

    def cancel(self):
        """
        Cancels this task, and all subtasks. See Task.cancel().
        """
        super().cancel()
        for task in self.subtasks:
            task.cancel()

    def add_task(self, task: Task):
        """
        Adds a subtask to this task. Note that subtasks should not be added after the task has been started, as they
        will not be connected correctly and will prevent the task from reporting a ``SUCCESS`` status.
        :param task: Task to add as a subtask.
        """
        self.subtasks.append(task)

    def wait(self, deadline=QDeadlineTimer.Forever):
        super().wait()
        for task in self.subtasks:
            task.wait()

    def _on_subtask_status_updated(self, status: Status):
        if status == Status.FAILURE:
            self.set_status(Status.FAILURE)
        elif status == Status.CANCELLED:
            self.set_status(Status.CANCELLED)
        elif status == Status.SUCCESS and all(t.get_status() == Status.SUCCESS for t in self.subtasks):
            self.set_status(Status.SUCCESS)
